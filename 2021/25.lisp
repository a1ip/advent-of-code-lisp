(in-package #:advent-of-code.2021.25)

;;; Advent of code 2021: day 25
;;; see https://adventofcode.com/2021/day/25

(defun make-board (h w)
  (make-array (list h w) :element-type '(unsigned-byte 2)))

(defun parse-input ()
  (let* ((lines (file-lines (my-input-path)))
	 (h (length lines))
	 (w (length (first lines)))
	 (board (make-board h w)))
    (loop for line in lines and y below h
	  do (loop for char across line
		   and x below w
		   do (setf (aref board y x)
			    (ecase (char line x)
			      (#\. 0) (#\v 1)
			      (#\> 2))))
	  finally (return board))))

(defun simulate (board)
  (destructuring-bind (h w) (array-dimensions board)
    (let ((east #1=(make-array (list h w) :element-type 'bit))
	  (south #2=(make-array (list h w) :element-type 'bit))
	  (new-east #1#)
	  (new-south #2#))
      (map-into (flat-array-alias east)
		(curry #'ldb (byte 1 1))
		(flat-array-alias board))
      (map-into (flat-array-alias south)
		(curry #'ldb (byte 1 0))
		(flat-array-alias board))

      (labels ((step-array (out this other xoff yoff)
		 (declare (bit xoff yoff))
		 (dotimes (y h)
		   (let ((y-before (mod (- y yoff) h))
			 (y-after (mod (+ y yoff) h)))
		     (dotimes (x w)
		       (let ((x-before (mod (- x xoff) w))
			     (x-after (mod (+ x xoff) w)))
			 (setf (aref out y x)
			       (logior
				(logand (aref this y-before x-before)
					(lognot (logior (aref this y x)
							(aref other y x))))
				(logand (aref this y x)
					(logior (aref this y-after x-after)
						(aref other y-after x-after))))))))))
	       (proceed ()
		 (step-array new-east east south 1 0)
		 (rotatef east new-east)
		 (step-array new-south south east 0 1)
		 (rotatef south new-south)))
	(loop for steps from 1 below 1000
	      do (proceed)
		 (when (and (equalp east new-east)
			    (equalp south new-south))
		   (return steps)))))))

(defun part-1 (&optional (data (parse-input)))
  (simulate data))

(defconstant +fbbw+ 16)
(deftype fbbyte () `(unsigned-byte ,+fbbw+))

(defun simulate-fb (board)
  (destructuring-bind (h w) (array-dimensions board)
    (let* ((bytew (ceiling w +fbbw+))
	   (bytew-floor (floor w +fbbw+))
	   (bytew-mod (mod w +fbbw+))
	   (bytew-xmod (if (zerop bytew-mod) +fbbw+ bytew-mod))
	   (east #1=(make-array (list h bytew) :element-type 'fbbyte))
	   (south #1#) (new-east #1#) (new-south #1#))
      (dotimes (y h)
	(dotimes (bx bytew)
	  (setf (aref east y bx)
		(loop for pos below (if (= bx (1- bytew))
					bytew-xmod +fbbw+)
		      for cell = (aref board y (+ pos (* bx +fbbw+)))
		      sum (ash (ldb (byte 1 1) cell) pos))
		(aref south y bx)
		(loop for pos below (if (= bx (1- bytew))
					bytew-xmod +fbbw+)
		      for cell = (aref board y (+ pos (* bx +fbbw+)))
		      sum (ash (ldb (byte 1 0) cell) pos)))))

      (flet ((proceed ()
	       (dotimes (y h)
		 (dotimes (bx bytew)
		   (let* ((now-present (aref east y bx))
			  (now-busy (logior now-present (aref south y bx)))
			  (ww-bx (mod (1- bx) bytew))
			  (ew-bx (mod (1+ bx) bytew))
			  (ww-present (logior (logand (ash now-present 1)
						      #.(1-(expt 2 +fbbw+)))
					      (ldb (byte 1 (if (= bx 0)
							       (1- bytew-xmod)
							       (1- +fbbw+)))
						   (aref east y ww-bx))))
			  (ew-busy (logior (ash now-busy -1)
					   (ash (ldb (byte 1 0)
						     (logior
						      (aref east y ew-bx)
						      (aref south y ew-bx)))
						    (if (= 0 ew-bx)
							(1- bytew-xmod)
							(1- +fbbw+))))))
		     (setf (aref new-east y bx)
			   (logior
			    (logand now-present ew-busy)
			    (logand ww-present (lognot now-busy)))))))
	       (rotatef east new-east)
	       (dotimes (y h)
		 (let ((sth-y (mod (1+ y) h))
		       (nth-y (mod (1- y) h)))
		   (dotimes (bx bytew)
		     (setf (aref new-south y bx)
			   (logior
			    (logand
			     (aref south y bx) ;; present now
			     (logior (aref south sth-y bx)
				     (aref east sth-y bx)))
			    (logand
			     (aref south nth-y bx)
			     (lognot (logior
				      (aref south y bx)
				      (aref east y bx)))))))))
	       (rotatef south new-south)))
	
	(loop for steps from 1 below 1000
	      do (proceed)
		 (when (and (equalp east new-east)
			    (equalp south new-south))
		   (return steps)))))))
